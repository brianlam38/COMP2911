import java.io.*;
import java.util.*;
import java.time.*;

/**
 * This class represents the entry point
 * for vans and van bookings.
 * 
 * It handles all booking requests, changes
 * and cancellations. It also stores info
 * for output printing purposes.
 *
 */
public class VanSystem {

	ArrayList<CamperVan> realVanList;		// True vanList
	ArrayList<CamperVan> vanListPrint;		// purely for output printing purposes (Cleans every instance of a booking, change, cancellation)
	int requestID;							// purely for output printing purposes (Cleans every instance of a booking, change, cancellation)
	
	public VanSystem() {
		this.realVanList = new ArrayList<CamperVan>();
		this.vanListPrint = new ArrayList<CamperVan>();
	}
	
	public void makeVanBooking(String type, int bookingID, LocalDateTime startDT, LocalDateTime endDT) {
		VanBooking booking = new VanBooking(type, bookingID, startDT, endDT);
		int arraySize = realVanList.size();
		for (int i = 0; i < arraySize; i++) {			// Scan through CamperVan list
			CamperVan van = realVanList.get(i);				// Grab van object
			if (!(van.type.equals(type))) continue;			// Skip vans that !requestedType
			int numBookings = van.bookings.size();
			for (int j = 0; j < numBookings; j++) {		// Scan through all Bookings per CamperVan
				if (van.bookings.isEmpty()) {				// No current bookings for CamperVan
					van.bookings.add(booking);				// Add booking object to CamperVan's booking list
				} else if (dateOverlap())
			}
		}
		// If error occurs, print "Booking rejected"
	}
	
	/**
	 * Converts month string to integer form.
	 */
	private static int monthToInt(String month) {
		String[] months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
		for (int i = 0; i < 12; i++) {
			if (month.equals(months[i])) {
				return i+1;
			}
		}
		return 0;
	}
	
	/**
	 * Compares start and end dates of two different
	 * periods to see if they overlap.
	 */
	public boolean dateOverlap(LocalDateTime start1, LocalDateTime start2, LocalDateTime end1, LocalDateTime end2) {
		LocalDateTime maxStart;
		if (start1.compareTo(start2) == 1) {	// Grab max(origStart, newStart)
			maxStart = start1;
		} else {
			maxStart = start2;
		}
		LocalDateTime minEnd;					// Grab min(originEnd, minEnd)
		if (end1.compareTo(end2) == -1) {
			minEnd = end1;
		} else {
			minEnd = end2;
		}
		if (minEnd.compareTo(maxStart) == 1) {
			return true;
		} else {
			return false;
		}
	}
	

}
