DESIGN
// Single truck, completing one job at a time.
// AIM: Schedule an optimal route for the truck to complete a joblist (set of jobs)
// Truck can be run continuously (perhaps with different drivers), so the system can focus on scheduling the optimal route
// The journey may include additional/multiple road trips from the end of one job to the start of the next job.

JOBLIST
// Joblist contains X number of distinct jobs
// Jobs inside joblist can be scheduled in any order
// First job always starts in SYDNEY

COSTS
// Travel costs between towns -> travel costs are the same in either direction between two towns
// Unloading cost for each job -> occurs when finishing a job

TOWNS
// Name of town = 1 word
// If there is no cost specified between two towns, it is not possible to travel between the two towns in one trip
// All jobs will only be between towns that ARE directly connected (can be done in one trip)

TRIANGLE INEQUALITY
// For any towns A, B, C, travel cost from (A->C) <= (A->B) + (B->C)

A* search in ASS_2
// Make use of the STRATEGY pattern to supply a heuristic to the A* search procedure.
// Implementing A* is the main requirement of the assignment, so that the program is guaranteed to produce at optimal solution.
// IF THE PROGRAM DOES NOT ALWAYS PRODUCE THE OPTIMAL SOLUTION, IT IS WRONG

A* search theory
// Djikstra's algo focuses on finding the shortest path possible and doesn't pay attention to which direction its going
// 		It is not optimal if say, you had a dense graph but edge weights were all the same.
//		It would have to go through every connecting node very slowly, rather than just going down the "correct" path
//		1. Push distances into priority queue
//		2. For each push / insertion, place distance in the correct order/position
//		   The PQ should always be sorted = minimum->maximum
//		3. Pop off top node / expand the node = remove node from PQ
// A* search focuses on your GOAL NODE / cares about the direction you're heading to.
// 		A* builds in a heuristics that tells us that we're getting close to the goal
//		A* is Djikstra + additional heuristic "how far do we have to go"
//		A reasonable heuristic = literally how far between point A to B in terms of EUCLIDEAN DISTANCE / STRAIGHT LINE

How A* works
// Same method as Djikstra, except we order the PQ by DISTANCE + HEURISTICS DISTANCE (straight line distance in this case) = Combined Heuristic
// Idea is that it will PRIORITISE NODES THAT ARE GOING IN ROUGHLY THE RIGHT DIRECTION




